Il programma incorpora diverse funzioni di utilità e supporto che gestiscono il tempo, la conversione dei dati e la memoria, fornendo l'infrastruttura necessaria per le simulazioni di logica digitale.

Funzioni di Gestione del Tempo
delay(int milliseconds)
Questa funzione è progettata per mettere in pausa l'esecuzione del programma per un numero specificato di millisecondi. Lo fa registrando un start_time usando clock(), calcolando un end_time basato sul ritardo desiderato e sulla macro CLOCKS_PER_SEC (che rappresenta i tick di clock al secondo), e quindi entrando in un ciclo di attesa attiva che continua finché il valore corrente di clock() non supera il end_time calcolato. Questo meccanismo è cruciale per simulare il passare del tempo in modo discreto, passo dopo passo, il che è essenziale per osservare il comportamento temporale dei circuiti digitali.   

clock_step(int *CLK, int *prev_CLK, int milliseconds)
La funzione clock_step simula la progressione di un segnale di clock in un sistema digitale. Introduce prima un ritardo usando la funzione delay, imitando la durata temporale di un ciclo di clock. Dopo questo ritardo, aggiorna la variabile prev_CLK con il valore corrente di CLK, e quindi commuta il segnale CLK da 0 a 1 o da 1 a 0 (rappresentato come 1 - *CLK). Questa commutazione sistematica del segnale CLK, insieme al tracciamento del suo stato precedente, è fondamentale per implementare la logica edge-triggered, dove le operazioni avvengono precisamente sul fronte di salita o di discesa di un impulso di clock.   

attendi_un_ciclo_clock()
Questa funzione simula specificamente il periodo di attesa per un singolo ciclo di clock. Similmente a delay, usa clock() per misurare il tempo, ma attende per una durata fissa equivalente a un millisecondo, derivata da CLOCKS_PER_SEC / 1000. Il suo ruolo principale è sincronizzare le operazioni all'interno della simulazione con un clock concettuale, assicurando che gli elementi logici sequenziali si comportino come farebbero in un vero circuito digitale clockato.   

misura_ciclo_clock()
La funzione misura_ciclo_clock svolge un ruolo pedagogico unico cercando di colmare il divario tra l'ambiente simulato e l'hardware reale. Tenta prima di rilevare il sistema operativo sottostante (Windows, Linux o macOS) e raccogliere alcune informazioni di base sulla CPU. Dopo questo rilevamento del sistema, procede a simulare 1000 cicli di clock usando attendi_un_ciclo_clock(). La funzione dichiara esplicitamente che "Un ciclo di clock richiede circa 1 millisecondo in questa simulazione", immediatamente seguita dalla chiarificazione cruciale: "Questo è solo un valore stimato. La CPU reale lavora molto più velocemente!". Questa affermazione diretta è una scelta di design deliberata che gestisce le aspettative dell'utente e rafforza la natura educativa e concettuale del programma. Aiuta gli utenti a capire che, sebbene la logica dei componenti simulati sia rappresentata accuratamente, la loro velocità non lo è, collegando così efficacemente la simulazione astratta alle realtà dell'architettura fisica del computer. Questo approccio favorisce una comprensione più profonda e accurata, impedendo agli utenti di interpretare erroneamente i ritardi simulati in millisecondi come velocità effettive della CPU.   

Funzioni di Conversione Dati
BIN_DEC_DECODER(const char *binario)
Questa funzione converte una stringa binaria nella sua equivalente valore intero decimale. Itera attraverso la stringa binaria di input, elaborando ogni carattere. Se un carattere è '1', aggiorna il valore decimale moltiplicando il decimale corrente per 2 e aggiungendo 1; se è '0', lo moltiplica per 2. La funzione include una robusta gestione degli errori, controllando input NULL e caratteri non validi (qualsiasi cosa diversa da '0' o '1'). Questa conversione è essenziale per consentire agli utenti di interagire con la logica binaria usando numeri decimali più familiari.   

DEC_BIN_CODER(int numero)
Al contrario, la funzione DEC_BIN_CODER converte un intero decimale nella sua rappresentazione in stringa binaria. Utilizza un ciclo while che prende ripetutamente il modulo 2 del numero per ottenere il bit meno significativo, lo aggiunge a un array di caratteri, e quindi divide il numero per 2. Ad esempio, se il numero è 5, otterrebbe prima 1 (5%2), poi 0 (2%2), poi 1 (1%2), risultando in "101". Poiché questo processo genera i bit in ordine inverso, un ciclo successivo viene utilizzato per invertire la stringa risultante per produrre la sequenza binaria corretta. Questa funzione consente la visualizzazione dei risultati numerici nella loro forma binaria, che è fondamentale per comprendere i sistemi digitali.   

Gestione e Visualizzazione della Memoria
Variabili di Memoria Globali (memoria, capacita_memoria, indice_memoria)
Il programma utilizza variabili globali per gestire un array dinamico che simula una semplice unità di memoria. memoria è un puntatore a un array di interi che memorizza i valori, capacita_memoria tiene traccia della dimensione allocata corrente di questo array, e indice_memoria tiene traccia della prossima posizione disponibile per memorizzare un nuovo valore. Queste variabili globali forniscono uno spazio di archiviazione condiviso a cui varie parti del sistema simulato possono accedere per memorizzare e recuperare risultati, imitando la funzione della memoria principale di un computer.   

salva_in_memoria(int valore)
Questa funzione è responsabile della memorizzazione di un valore intero nella memoria simulata. Alloca dinamicamente memoria per l'array memoria se è inizialmente NULL. Un aspetto critico di questa funzione è la sua strategia di espansione della memoria: se indice_memoria (numero di celle occupate) raggiunge o supera capacita_memoria (celle totali allocate), la funzione raddoppia capacita_memoria e rialloca l'array memoria usando realloc. Questo ridimensionamento dinamico assicura che la memoria possa crescere secondo necessità per accogliere più valori memorizzati senza una limitazione di dimensione fissa, una tecnica comune nel software per gestire carichi di dati variabili. La gestione degli errori è inclusa per gestire i fallimenti di allocazione.   

stampa_memoria()
La funzione stampa_memoria itera attraverso le celle attualmente occupate dell'array memoria e stampa ogni valore memorizzato insieme al suo indice. Questo fornisce una chiara rappresentazione testuale dei dati attualmente contenuti nella memoria simulata.   

stato_memoria()
Questa funzione fornisce un riepilogo dello stato attuale della memoria simulata. Riporta sia la capacita_memoria (celle totali allocate) che l'indice_memoria (celle occupate). Queste informazioni sono utili per monitorare l'utilizzo della memoria e comprendere il comportamento di allocazione dinamica della funzione salva_in_memoria.   

Implementazioni di Porte Logiche Fondamentali
Il cuore della simulazione di logica digitale in questo programma risiede nelle funzioni che implementano le porte logiche booleane fondamentali. Tutte le funzioni all'interno di questa sezione (porta_not, porta_and, porta_or, porta_exor, NAND3, e le loro varianti multi-input) sono progettate per operare su input binari (rappresentati come interi 0 o 1) e produrre un output binario corrispondente (0 o 1). Implementano le rispettive operazioni logiche booleane usando l'aritmetica intera standard, dove 0 rappresenta costantemente FALSO logico e 1 rappresenta VERO logico.

porta_not(int a)
Questa funzione implementa l'operazione logica fondamentale NOT (inverter). Restituisce il complemento dell'input: se a è 0, restituisce 1; se a è 1, restituisce 0. L'espressione aritmetica 1 - a lo realizza perfettamente per input binari.   

porta_and(int a, int b)
La funzione porta_and implementa l'operazione logica AND per due input binari. Restituisce 1 solo se sia a che b sono 1; altrimenti, restituisce 0. La moltiplicazione a * b simula correttamente questo comportamento per input binari.   

porta_or(int a, int b)
Questa funzione implementa l'operazione logica OR per due input binari. Restituisce 1 se almeno uno degli input (a o b) è 1; restituisce 0 solo se entrambi gli input sono 0. La formula (a + b) - (a * b) è una rappresentazione aritmetica comune e corretta della porta OR per input binari, impedendo che la somma superi 1 quando entrambi gli input sono 1.   

porta_exor(int a, int b)
La funzione porta_exor implementa l'operazione logica Exclusive OR (XOR) per due input binari. Restituisce 1 se gli input a e b sono diversi (uno è 0 e l'altro è 1); restituisce 0 se sono uguali (entrambi 0 o entrambi 1). La formula (a + b) - 2 * (a * b) simula accuratamente questo comportamento per input binari.   

NAND3(int A, int B, int C)
Questa funzione implementa l'operazione logica NAND per tre input binari. Restituisce 0 solo se tutti e tre gli input (A, B e C) sono 1; altrimenti, restituisce 1. Questo è equivalente alla negazione di una porta AND a tre input, che è correttamente rappresentato da 1 - (A * B * C).   

Porte Logiche Multi-input (porta_or_3 a porta_exor_5)
Queste funzioni estendono la funzionalità delle porte logiche di base a 2 input per gestire un numero maggiore di input (specificamente 3, 4 o 5 input). Invece di implementare nuove espressioni booleane complesse, queste funzioni raggiungono il loro scopo concatenando chiamate alle loro controparti più semplici a 2 input. Ad esempio, una porta OR a 3 input (porta_or_3) è implementata eseguendo un'operazione OR sui primi due input (a e b) per ottenere un risultato intermedio (tmp), e quindi eseguendo l'OR di quel risultato intermedio con il terzo input (c). Questo approccio modulare rispecchia direttamente il modo in cui tale logica è spesso costruita in circuiti digitali reali usando componenti discreti o all'interno di circuiti integrati più grandi. Questa strategia di implementazione dimostra potentemente il principio della composizione delle porte, illustrando che qualsiasi funzione booleana complessa può essere realizzata combinando un insieme limitato di porte logiche fondamentali. Questa modularità è fondamentale per la progettazione di sistemi digitali scalabili e gestibili, poiché consente agli ingegneri di costruire circuiti sempre più complessi da un insieme ben definito di blocchi costruttivi di base.   

Implementazioni di Logica Sequenziale e Registri
Gli elementi di logica sequenziale sono i blocchi costruttivi fondamentali per la memoria e le macchine a stati nei sistemi digitali, consentendo ai circuiti di memorizzare informazioni e alle loro uscite di dipendere non solo dagli input correnti ma anche dagli input passati.

n_SR_FLIP_FLOP(int D, int S_reg, int R_reg, int CLK, int *prev_CLK, int *Q, int *Q_bar)
Questa funzione simula il comportamento di un flip-flop di tipo D, un elemento di memoria cruciale nei circuiti digitali. È progettata per essere attivata da un fronte di salita del segnale di clock e include input Set (S_reg) e Reset (R_reg) asincroni.
Il cuore della sua operazione è il rilevamento del fronte di clock: la condizione (CLK * (1 - *prev_CLK)) == 1 identifica precisamente quando il segnale CLK transita da 0 a 1, significando un fronte di salita del clock. Questo è il momento specifico in cui lo stato del flip-flop può cambiare in base al suo input dati. Quando viene rilevato un fronte di salita, il valore dell'input D (Data) viene trasferito all'output Q. Internamente, la logica usa J = D e K = 1 - D, che è un metodo standard per configurare un flip-flop JK in modo che si comporti come un flip-flop di tipo D. Gli input S_reg e R_reg forniscono controllo asincrono: se S_reg è 0 (Set attivo-basso), l'output Q viene immediatamente forzato a 1, ignorando qualsiasi comportamento clockato. Allo stesso modo, se R_reg è 0 (Reset attivo-basso), Q viene forzato a 0 (e Q_bar a 1). Questi input sono tipicamente usati per l'inizializzazione o i reset di emergenza nell'hardware reale. Gli output Q e Q_bar (complemento di Q) vengono aggiornati usando porte NAND3, che sono blocchi costruttivi comuni per implementare vari tipi di flip-flop.
Nonostante il nome della funzione n_SR_FLIP_FLOP (che potrebbe suggerire un flip-flop SR), l'implementazione effettiva si comporta come un flip-flop di tipo D attivato sul fronte di salita con set/reset asincroni attivi-bassi. Il prefisso n_ probabilmente si riferisce alla natura attivo-bassa degli input S_reg e R_reg, che è tipica di molti chip logici standard. Questa funzione, nonostante il suo nome potenzialmente fuorviante, fornisce una sofisticata simulazione software di un flip-flop di tipo D. Dimostra come gli elementi logici sequenziali, che sono i blocchi costruttivi fondamentali della memoria e delle macchine a stati nei computer, si basano su precisi fronti di clock e cicli di feedback interni (Q e Q_bar che rientrano nelle porte NAND) per mantenere e aggiornare il loro stato. L'inclusione di input set/reset asincroni illustra ulteriormente le considerazioni pratiche dell'hardware per l'inizializzazione e il controllo. Comprendere i flip-flop è fondamentale per capire come i computer memorizzano e manipolano i dati nel tempo.   

n_PIPO74198(int D, int S_reg, int R_reg, int CLK, int prev_CLK, int Q, int Q_bar)
Questa funzione simula un registro Parallel-In, Parallel-Out (PIPO) a 8 bit, un tipo comune di registro utilizzato per l'archiviazione e la manipolazione temporanea dei dati nei sistemi digitali. Costruisce questo registro a 8 bit iterando otto volte. In ogni iterazione, istanzia e chiama un singolo n_SR_FLIP_FLOP (la simulazione del flip-flop di tipo D) per ogni singolo bit. Ciò significa che ogni bit dei dati di input a 8 bit (D[i]) viene memorizzato indipendentemente nel proprio flip-flop, e i loro output corrispondenti (Q[i], Q_bar[i]) vengono prodotti in parallelo. Ogni flip-flop simulato mantiene il proprio stato S_reg, R_reg e prev_CLK, garantendo un funzionamento indipendente all'interno del registro. Questa funzione dimostra chiaramente un principio fondamentale nella progettazione digitale: come un registro multi-bit è costruito aggregando più elementi di memoria a singolo bit (flip-flop). La natura "Parallel-In, Parallel-Out" implica che tutti gli 8 bit possono essere caricati simultaneamente e letti simultaneamente, il che è cruciale per un trasferimento efficiente dei dati nei sistemi informatici. Questa struttura parallela è una pietra angolare del modo in cui i dati vengono memorizzati e spostati all'interno di una CPU.   

reg_PIPO32(int D, int S_reg, int R_reg, int CLK, int prev_CLK, int Q, int Q_bar)
Questa funzione simula un registro Parallel-In, Parallel-Out (PIPO) più grande, a 32 bit, che è rappresentativo della larghezza del percorso dati in molte architetture di computer moderne. Si basa su n_PIPO74198 (la simulazione del registro PIPO a 8 bit) chiamandola quattro volte. Ogni chiamata gestisce un "nibble" a 8 bit (un termine per 4 bit, anche se qui usato per segmenti a 8 bit) dei dati totali a 32 bit passando un puntatore all'inizio di ogni segmento a 8 bit degli array a 32 bit. Questo approccio modulare illustra efficacemente come registri più grandi e complessi siano costruiti combinando moduli di registro più piccoli e standardizzati, una pratica comune nella progettazione di circuiti integrati. Questa funzione dimostra potentemente il principio di scalabilità nella progettazione digitale. Riutilizzando il modulo di registro PIPO a 8 bit già definito, viene creato in modo efficiente un registro a 32 bit significativamente più grande. Questa costruzione gerarchica è una pietra angolare della progettazione di chip moderni, consentendo agli ingegneri di gestire la complessità costruendo sistemi da sotto-componenti ben definiti, testati e riutilizzabili. Evidenzia come gli elementi architettonici crescano in complessità combinando blocchi funzionali più semplici.   

Implementazioni di Unità Aritmetico-Logiche (ALU)
L'Unità Aritmetico-Logica (ALU) è un componente fondamentale di un'unità di elaborazione centrale (CPU), responsabile dell'esecuzione di operazioni aritmetiche e logiche.

n_ALU74181(int Cn, int M, int A, int B, int S, int F, int *A_uguale_B, int *P, int *Cn_piu_4, int *G)
Questa funzione simula un'Unità Aritmetico-Logica (ALU) a 4 bit, modellando specificamente la funzionalità di un chip storico ma altamente illustrativo, il 74181. Prende diversi input: Cn per il carry-in, M per il controllo della modalità (che determina se l'operazione è aritmetica o logica), A e B per i due operandi a 4 bit, e S per selezionare l'operazione specifica da eseguire. I suoi output includono F per il risultato a 4 bit dell'operazione, A_uguale_B che indica se gli operandi A e B sono uguali, P per il segnale di propagazione, Cn_piu_4 per il carry-out, e G per il segnale di generazione.
La logica interna per il calcolo di F a F, A_uguale_B, P, Cn_piu_4 e G coinvolge espressioni booleane altamente complesse che combinano varie porte logiche (porta_not, porta_and, porta_or, porta_exor, e le loro varianti multi-input). Queste intricate espressioni sono derivate direttamente dalla tabella di verità e dalla logica interna del 74181, rappresentando una forma altamente condensata di implementazione della logica digitale a livello di porta. Questa funzione rappresenta un componente centrale di una CPU, responsabile dell'esecuzione di operazioni sia aritmetiche (es. addizione, sottrazione) che logiche (es. AND, OR, XOR). Il 74181 è stato un chip fondamentale perché poteva eseguire una vasta gamma di operazioni basate su segnali di controllo, dimostrando i principi fondamentali di un'ALU per scopi generali. Le intricate espressioni booleane per i suoi output illustrano la complessità sottostante richiesta per implementare una logica digitale così versatile a livello di porta. La capacità di selezionare le operazioni tramite gli input S e la modalità M è una caratteristica chiave dell'hardware programmabile, consentendo a un singolo circuito di eseguire più funzioni distinte.   

simula_alu_74181()
Questa funzione fornisce un'interfaccia utente per testare interattivamente la funzione n_ALU74181. Gli utenti possono scegliere di inserire i bit Cn, M, A, B e S manualmente o caricarli da un file input_alu.txt. La funzione include un'ampia validazione dell'input per garantire che tutti i valori inseriti siano strettamente 0 o 1, fornendo messaggi di errore facili da usare per input non validi. Dopo aver eseguito la simulazione n_ALU74181, visualizza i risultati per F a F, A_uguale_B, P, Cn_piu_4 e G sulla console e li salva in un file risultati_alu_74181.txt. Il suo ruolo è consentire agli utenti di interagire e osservare il comportamento dell'ALU a 4 bit simulata, fornendo una dimostrazione pratica della sua funzionalità in varie condizioni di input e rafforzando i concetti teorici appresi dall'implementazione di n_ALU74181.   

ALU32()
Questa funzione simula un'ALU a 32 bit, una scala più pratica per i processori moderni, concatenando più componenti n_ALU74181 a 4 bit. Richiede all'utente due operandi decimali a 32 bit (operandoA, operandoB) e segnali di controllo (Cn, M, S). Similmente a simula_alu_74181, supporta sia l'input manuale che quello basato su file, completo di validazione.
Il processo inizia convertendo gli operandi decimali in array binari a 32 bit (D_A, D_B). Questi array binari vengono quindi caricati in registri PIPO a 32 bit simulati usando reg_PIPO32, dimostrando il caricamento iniziale dei dati negli elementi di memoria sequenziale. Il cuore dell'operazione dell'ALU a 32 bit coinvolge un processo iterativo: gli operandi a 32 bit vengono elaborati in otto segmenti a 4 bit (nibble). Per ogni nibble, viene chiamata la funzione n_ALU74181, e un aspetto critico delle operazioni aritmetiche viene simulato passando il carry-out (Cn_piu_4) da uno stadio ALU a 4 bit come carry-in (currentCn) per lo stadio successivo. Questo meccanismo illustra accuratamente l'addizione/sottrazione ripple-carry, un metodo fondamentale per eseguire operazioni aritmetiche multi-bit. Il risultato finale a 32 bit viene ricostruito dai risultati dei singoli nibble e memorizzato in memoria. Questa funzione mostra come un'ALU più grande e pratica (come quelle che si trovano nelle CPU reali) sia costruita da unità ALU modulari più piccole. Il meccanismo di propagazione del ripple-carry, in cui l'output di carry di uno stadio alimenta il successivo, è un metodo classico per eseguire operazioni aritmetiche multi-bit. Questa progettazione gerarchica e la propagazione del carry sono concetti fondamentali nella costruzione di circuiti aritmetici efficienti e scalabili, dimostrando come funzionalità complesse siano costruite su componenti più semplici e ripetibili.   

Operazioni Algebriche di Base
Oltre alla simulazione dettagliata dei circuiti logici digitali, il programma include anche funzioni per eseguire operazioni algebriche di base, dimostrando un livello di astrazione superiore.

somma(int a, int b)
Questa funzione esegue una semplice addizione di interi, restituendo la somma dei suoi due input interi, a e b.   

sottrazione(int a, int b)
Questa funzione esegue una semplice sottrazione di interi, restituendo la differenza tra i suoi due input interi, a e b.   

moltiplicazione(int a, int b)
Questa funzione esegue una semplice moltiplicazione di interi, restituendo il prodotto dei suoi due input interi, a e b.   

divisione(int a, int b)
Questa funzione esegue la divisione intera, restituendo il quoziente di a diviso per b. Include una gestione essenziale degli errori per prevenire la divisione per zero, stampando un messaggio di errore e restituendo 0 in tali casi.   

operazioni_algebriche()
Questa funzione fornisce un'interfaccia utente per eseguire operazioni aritmetiche di base utilizzando le funzioni somma, sottrazione, moltiplicazione e divisione. Chiede all'utente di scegliere tra 2 o 3 operandi. Per due operandi, supporta tutte e quattro le operazioni aritmetiche di base. Per tre operandi, supporta solo somma e moltiplicazione, dimostrando come queste operazioni possano essere concatenate (es. somma(somma(a, b), c)). La funzione include la validazione dell'input per il numero di elementi e l'operazione scelta, accettando sia scelte numeriche che nomi di stringa per le operazioni. Il risultato di ogni operazione viene salvato nella memoria simulata. Questa funzione serve come astrazione di livello superiore, dimostrando come le capacità aritmetiche fondamentali (che potrebbero essere implementate da ALU a un livello inferiore) siano esposte a un utente per il calcolo diretto. Evidenzia la natura a strati dei sistemi informatici, dove operazioni complesse sono costruite su quelle più semplici, fornendo in ultima analisi utilità funzionale all'utente finale.   

Flusso Principale del Programma
main() La funzione main funge da punto di ingresso e unità di controllo centrale dell'intero programma. Presenta un'interfaccia a menu all'utente, consentendogli di selezionare varie opzioni di simulazione e utilità all'interno di un ciclo while(1) continuo. Le opzioni del menu includono:   
- Simulazioni di operazioni ALU a 4 bit (con e senza visualizzazione del clock).
- Operazioni algebriche di base.
- Conversioni da binario a decimale e da decimale a binario.
- Simulazioni di operazioni ALU a 32 bit (con e senza visualizzazione del clock).
- Visualizzazione del contenuto e dello stato della memoria simulata.
- Misurazione del ciclo di clock simulato.
- Uscita dal programma. In base alla scelta intera dell'utente, la funzione main orchestra le chiamate alle rispettive funzioni. Include una chiamata sleep(2) dopo la maggior parte delle operazioni, introducendo una breve pausa per una migliore esperienza utente. All'uscita dal programma (quando l'utente seleziona l'opzione 0), esegue una pulizia cruciale della memoria liberando l'array memoria allocato dinamicamente, dimostrando buone pratiche di gestione della memoria. La funzione main agisce come unità di controllo centrale, analoga a un sistema operativo o a un'applicazione di alto livello che gestisce vari componenti hardware e software. Lega insieme tutta la logica digitale simulata e le funzioni di utilità in uno strumento educativo coeso e interattivo. Il menu strutturato e la robusta gestione degli input esemplificano i principi di base della progettazione del programma per l'interazione con l'utente, rendendo accessibili le complesse simulazioni sottostanti.
